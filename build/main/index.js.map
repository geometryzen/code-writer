{"version":3,"file":"index.js","sources":["../../src/MutablePosition.ts","../../src/asserts.ts","../../src/MutableRange.ts","../../src/Position.ts","../../src/Range.ts","../../src/MappingTree.ts","../../src/CodeWriter.ts"],"sourcesContent":["\nexport class MutablePosition {\n    constructor(public line: number, public column: number) {\n        // TODO\n    }\n    offset(rows: number, cols: number) {\n        this.line += rows;\n        this.column += cols;\n    }\n    toString(): string {\n        return `[${this.line}, ${this.column}]`;\n    }\n}\n","/**\n * We're looking for something that is truthy, not just true.\n */\nexport function assert(condition: unknown, message?: string): void {\n    if (!condition) {\n        throw new Error(message);\n    }\n}\n\nexport function fail(message: string): void {\n    assert(false, message);\n}\n","import { assert } from './asserts';\nimport { MutablePosition } from './MutablePosition';\n\nexport class MutableRange {\n    /**\n     *\n     */\n    constructor(public readonly begin: MutablePosition, public readonly end: MutablePosition) {\n        assert(begin, \"begin must be defined\");\n        assert(end, \"end must be defined\");\n        this.begin = begin;\n        this.end = end;\n    }\n    offset(rows: number, cols: number): void {\n        this.begin.offset(rows, cols);\n        this.end.offset(rows, cols);\n    }\n    toString(): string {\n        return `${this.begin} to ${this.end}`;\n    }\n}\n","export class Position {\n    /**\n     * 1-based line number.\n     */\n    public readonly line: number;\n    /**\n     * 0-based column index.\n     */\n    public readonly column: number;\n    /**\n     *\n     */\n    constructor(line: number, column: number) {\n        this.line = line;\n        this.column = column;\n    }\n    toString(): string {\n        return `[${this.line}, ${this.column}]`;\n    }\n}\n\nexport function positionComparator(a: Position, b: Position): -1 | 1 | 0 {\n    if (a.line < b.line) {\n        return -1;\n    }\n    else if (a.line > b.line) {\n        return 1;\n    }\n    else {\n        if (a.column < b.column) {\n            return -1;\n        }\n        else if (a.column > b.column) {\n            return 1;\n        }\n        else {\n            return 0;\n        }\n    }\n}\n","import { assert } from './asserts';\nimport { Position } from './Position';\n\nexport class Range {\n    /**\n     * begin is always defined.\n     */\n    public readonly begin: Position;\n    /**\n     * end is always defined.\n     */\n    public readonly end: Position;\n    /**\n     *\n     */\n    constructor(begin: Position, end: Position) {\n        assert(begin, \"begin must be defined\");\n        assert(end, \"end must be defined\");\n        this.begin = begin;\n        this.end = end;\n    }\n    toString(): string {\n        return `${this.begin} to ${this.end}`;\n    }\n}\n","import { assert } from './asserts';\nimport { Range } from './Range';\nimport { MutableRange } from './MutableRange';\n\n/**\n * A tree that enables ranges in the source document to be mapped to ranges in the target document.\n * The ordering of child nodes is not defined.\n * In many cases the children will be in target order owing to the writing process.\n * TODO: For more efficient searching, children should be sorted in source order.\n */\nexport class MappingTree {\n    /**\n     * source is always defined.\n     */\n    public readonly source: Range;\n    /**\n     * target is always defined.\n     */\n    public readonly target: MutableRange;\n    /**\n     *\n     * @param source\n     * @param target\n     * @param children\n     */\n    constructor(source: Range, target: MutableRange, public readonly children: MappingTree[]) {\n        assert(source, \"source must be defined\");\n        assert(target, \"target must be defined\");\n        this.source = source;\n        this.target = target;\n    }\n    offset(rows: number, cols: number) {\n        if (this.target) {\n            this.target.offset(rows, cols);\n        }\n        if (this.children) {\n            for (const child of this.children) {\n                child.offset(rows, cols);\n            }\n        }\n    }\n    mappings(): { source: Range, target: MutableRange }[] {\n        if (this.children) {\n            const maps: { source: Range, target: MutableRange }[] = [];\n            for (const child of this.children) {\n                for (const map of child.mappings()) {\n                    maps.push(map);\n                }\n            }\n            return maps;\n        }\n        else {\n            return [{ source: this.source, target: this.target }];\n        }\n    }\n}\n","import { assert } from './asserts';\nimport { Position } from './Position';\nimport { Range } from './Range';\nimport { MutablePosition } from './MutablePosition';\nimport { MutableRange } from './MutableRange';\nimport { MappingTree } from './MappingTree';\n\nexport enum IndentStyle {\n    None = 0,\n    Block = 1,\n    Smart = 2,\n}\n\nexport interface EditorOptions {\n    baseIndentSize?: number;\n    indentSize?: number;\n    tabSize?: number;\n    newLineCharacter?: string;\n    convertTabsToSpaces?: boolean;\n    indentStyle?: IndentStyle;\n}\n\nexport interface FormatCodeOptions extends EditorOptions {\n    insertSpaceAfterCommaDelimiter?: boolean;\n    insertSpaceAfterSemicolonInForStatements?: boolean;\n    insertSpaceBeforeAndAfterBinaryOperators?: boolean;\n    insertSpaceAfterConstructor?: boolean;\n    insertSpaceAfterKeywordsInControlFlowStatements?: boolean;\n    insertSpaceAfterFunctionKeywordForAnonymousFunctions?: boolean;\n    insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis?: boolean;\n    insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets?: boolean;\n    insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces?: boolean;\n    insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces?: boolean;\n    insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces?: boolean;\n    insertSpaceAfterTypeAssertion?: boolean;\n    insertSpaceBeforeFunctionParenthesis?: boolean;\n    placeOpenBraceOnNewLineForFunctions?: boolean;\n    placeOpenBraceOnNewLineForControlBlocks?: boolean;\n}\n\nclass StackElement {\n    private readonly texts: string[] = [];\n    private readonly trees: MappingTree[] = [];\n    // FIXME: A mutable position can be renamed to a Cursor.\n    private readonly cursor: MutablePosition;\n    constructor(public readonly bMark: string, public readonly eMark: string, targetBeginLine: number, targetBeginColumn: number) {\n        this.cursor = new MutablePosition(targetBeginLine, targetBeginColumn);\n    }\n    /**\n     *\n     */\n    write(text: string, tree: MappingTree): void {\n        assert(typeof text === 'string', \"text must be a string\");\n        this.texts.push(text);\n        this.trees.push(tree);\n\n        const cursor = this.cursor;\n        const beginLine = cursor.line;\n        const beginColumn = cursor.column;\n        const endLine = cursor.line;\n        const endColumn = beginColumn + text.length;\n        if (tree) {\n            tree.target.begin.line = beginLine;\n            tree.target.begin.column = beginColumn;\n            tree.target.end.line = endLine;\n            tree.target.end.column = endColumn;\n        }\n        cursor.line = endLine;\n        cursor.column = endColumn;\n    }\n    snapshot(): { text: string; tree: MappingTree; targetEndLine: number; targetEndColumn: number } {\n        const texts = this.texts;\n        const trees = this.trees;\n        const N = texts.length;\n        if (N === 0) {\n            return this.package('', null);\n        }\n        else {\n            let sBL = Number.MAX_SAFE_INTEGER;\n            let sBC = Number.MAX_SAFE_INTEGER;\n            let sEL = Number.MIN_SAFE_INTEGER;\n            let sEC = Number.MIN_SAFE_INTEGER;\n            let tBL = Number.MAX_SAFE_INTEGER;\n            let tBC = Number.MAX_SAFE_INTEGER;\n            let tEL = Number.MIN_SAFE_INTEGER;\n            let tEC = Number.MIN_SAFE_INTEGER;\n            const children: MappingTree[] = [];\n            for (let i = 0; i < N; i++) {\n                const tree = trees[i];\n                if (tree) {\n                    sBL = Math.min(sBL, tree.source.begin.line);\n                    sBC = Math.min(sBC, tree.source.begin.column);\n                    sEL = Math.max(sEL, tree.source.end.line);\n                    sEC = Math.max(sEC, tree.source.end.column);\n\n                    tBL = Math.min(tBL, tree.target.begin.line);\n                    tBC = Math.min(tBC, tree.target.begin.column);\n                    tEL = Math.max(tEL, tree.target.end.line);\n                    tEC = Math.max(tEC, tree.target.end.column);\n\n                    children.push(tree);\n                }\n            }\n            const text = texts.join(\"\");\n            if (children.length > 1) {\n                const source = new Range(new Position(sBL, sBC), new Position(sEL, sEC));\n                const target = new MutableRange(new MutablePosition(tBL, tBC), new MutablePosition(tEL, tEC));\n                return this.package(text, new MappingTree(source, target, children));\n            }\n            else if (children.length === 1) {\n                return this.package(text, children[0]);\n            }\n            else {\n                return this.package(text, null);\n            }\n        }\n    }\n    private package(text: string, tree: MappingTree): { text: string; tree: MappingTree; targetEndLine: number; targetEndColumn: number } {\n        return { text, tree, targetEndLine: this.cursor.line, targetEndColumn: this.cursor.column };\n    }\n\n    public getLine(): number {\n        return this.cursor.line;\n    }\n    public getColumn(): number {\n        return this.cursor.column;\n    }\n}\n\nfunction IDXLAST<T>(xs: ArrayLike<T>): number {\n    return xs.length - 1;\n}\n\n/**\n *\n */\nclass Stack {\n    private readonly elements: StackElement[] = [];\n    constructor(begin: string, end: string, targetLine: number, targetColumn: number) {\n        this.elements.push(new StackElement(begin, end, targetLine, targetColumn));\n    }\n    get length() {\n        return this.elements.length;\n    }\n    push(element: StackElement): void {\n        this.elements.push(element);\n    }\n    pop(): StackElement {\n        return this.elements.pop();\n    }\n    write(text: string, tree: MappingTree): void {\n        this.elements[IDXLAST(this.elements)].write(text, tree);\n    }\n    dispose(): TextAndMappings {\n        assert(this.elements.length === 1, \"stack length should be 1\");\n        const textAndMappings = this.elements[IDXLAST(this.elements)].snapshot();\n        this.pop();\n        assert(this.elements.length === 0, \"stack length should be 0\");\n        return textAndMappings;\n    }\n    getLine(): number {\n        return this.elements[IDXLAST(this.elements)].getLine();\n    }\n    getColumn(): number {\n        return this.elements[IDXLAST(this.elements)].getColumn();\n    }\n}\n\nexport interface TextAndMappings {\n    text: string;\n    tree: MappingTree;\n}\n\n/**\n * A smart buffer for writing TypeScript code.\n */\nexport class CodeWriter {\n    private readonly stack: Stack;\n    /**\n     * Determines the indentation.\n     */\n    // private indentLevel = 0;\n    /**\n     * Constructs a CodeWriter instance using the specified options.\n     */\n    constructor(beginLine: number, beginColumn: number, private options: FormatCodeOptions = {}) {\n        this.stack = new Stack('', '', beginLine, beginColumn);\n    }\n    assign(text: '=', source: Range): void {\n        const target = new MutableRange(new MutablePosition(-3, -3), new MutablePosition(-3, -3));\n        const tree = new MappingTree(source, target, null);\n        this.stack.write(text, tree);\n    }\n    /**\n     * Writes a name (identifier).\n     * @param id The identifier string to be written.\n     * @param begin The position of the beginning of the name in the original source.\n     * @param end The position of the end of the name in the original source.\n     */\n    name(id: string, source: Range): void {\n        if (source) {\n            const target = new MutableRange(new MutablePosition(-2, -2), new MutablePosition(-2, -2));\n            const tree = new MappingTree(source, target, null);\n            this.stack.write(id, tree);\n        }\n        else {\n            this.stack.write(id, null);\n        }\n    }\n    num(text: string, source: Range): void {\n        if (source) {\n            const target = new MutableRange(new MutablePosition(-3, -3), new MutablePosition(-3, -3));\n            const tree = new MappingTree(source, target, null);\n            this.stack.write(text, tree);\n        }\n        else {\n            this.stack.write(text, null);\n        }\n    }\n    /**\n     * Currently defined to be for string literals in unparsed form.\n     */\n    str(text: string, source: Range): void {\n        if (source) {\n            const target = new MutableRange(new MutablePosition(-23, -23), new MutablePosition(-23, -23));\n            const tree = new MappingTree(source, target, null);\n            this.stack.write(text, tree);\n        }\n        else {\n            this.stack.write(text, null);\n        }\n    }\n    write(text: string, tree: MappingTree): void {\n        this.stack.write(text, tree);\n    }\n    snapshot(): TextAndMappings {\n        assert(this.stack.length === 1, \"stack length is not zero\");\n        return this.stack.dispose();\n    }\n    binOp(binOp: '+' | '-' | '*' | '/' | '|' | '^' | '&' | '<<' | '>>' | '%' | '//' | '**', source: Range): void {\n        const target = new MutableRange(new MutablePosition(-5, -5), new MutablePosition(-5, -5));\n        const tree = new MappingTree(source, target, null);\n        if (this.options.insertSpaceBeforeAndAfterBinaryOperators) {\n            this.space();\n            this.stack.write(binOp, tree);\n            this.space();\n        }\n        else {\n            this.stack.write(binOp, tree);\n        }\n    }\n    unaryOp(unaryOp: '+' | '-' | '~' | '!', source: Range): void {\n        const target = new MutableRange(new MutablePosition(-5, -5), new MutablePosition(-5, -5));\n        const tree = new MappingTree(source, target, null);\n        this.stack.write(unaryOp, tree);\n    }\n    comma(begin: Position | null, end: Position | null): void {\n        if (begin && end) {\n            const source = new Range(begin, end);\n            const target = new MutableRange(new MutablePosition(-4, -4), new MutablePosition(-4, -4));\n            const tree = new MappingTree(source, target, null);\n            this.stack.write(',', tree);\n        }\n        else {\n            this.stack.write(',', null);\n        }\n        if (this.options.insertSpaceAfterCommaDelimiter) {\n            this.stack.write(' ', null);\n        }\n    }\n    space(): void {\n        this.stack.write(' ', null);\n    }\n    beginBlock(): void {\n        this.prolog('{', '}');\n    }\n    endBlock(): void {\n        this.epilog(false);\n    }\n    beginBracket(): void {\n        this.prolog('[', ']');\n    }\n    endBracket(): void {\n        this.epilog(this.options.insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets);\n    }\n    beginObject(): void {\n        this.prolog('{', '}');\n    }\n    endObject(): void {\n        this.epilog(this.options.insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces);\n    }\n    openParen(): void {\n        this.prolog('(', ')');\n    }\n    closeParen(): void {\n        this.epilog(this.options.insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis);\n    }\n    beginQuote(): void {\n        this.prolog(\"'\", \"'\");\n    }\n    endQuote(): void {\n        this.epilog(false);\n    }\n    beginStatement(): void {\n        this.prolog('', ';');\n    }\n    endStatement(): void {\n        this.epilog(false);\n    }\n    private prolog(bMark: string, eMark: string): void {\n        const line = this.stack.getLine();\n        const column = this.stack.getColumn();\n        this.stack.push(new StackElement(bMark, eMark, line, column));\n    }\n    private epilog(insertSpaceAfterOpeningAndBeforeClosingNonempty: boolean | undefined): void {\n        const popped = this.stack.pop();\n        const textAndMappings = popped.snapshot();\n        const text = textAndMappings.text;\n        const tree = textAndMappings.tree;\n        // This is where we would be\n        // const line = textAndMappings.targetEndLine;\n        // const column = textAndMappings.targetEndColumn;\n        if (text.length > 0 && insertSpaceAfterOpeningAndBeforeClosingNonempty) {\n            this.write(popped.bMark, null);\n            this.space();\n            const rows = 0;\n            const cols = popped.bMark.length + 1;\n            if (tree) {\n                tree.offset(rows, cols);\n            }\n            this.write(text, tree);\n            this.space();\n            this.write(popped.eMark, null);\n        }\n        else {\n            this.write(popped.bMark, null);\n            const rows = 0;\n            const cols = popped.bMark.length;\n            if (tree) {\n                tree.offset(rows, cols);\n            }\n            this.write(text, tree);\n            this.write(popped.eMark, null);\n        }\n    }\n}\n"],"names":["IndentStyle"],"mappings":"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"}