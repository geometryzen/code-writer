{"version":3,"file":"index.js","sources":["../../src/MutablePosition.ts","../../src/asserts.ts","../../src/MutableRange.ts","../../src/Position.ts","../../src/Range.ts","../../src/MappingTree.ts","../../src/CodeWriter.ts"],"sourcesContent":["\nexport class MutablePosition {\n    constructor(public line: number, public column: number) {\n        // TODO\n    }\n    offset(rows: number, cols: number) {\n        this.line += rows;\n        this.column += cols;\n    }\n    toString(): string {\n        return `[${this.line}, ${this.column}]`;\n    }\n}\n","/**\n * We're looking for something that is truthy, not just true.\n */\nexport function assert(condition: unknown, message?: string): void {\n    if (!condition) {\n        throw new Error(message);\n    }\n}\n\nexport function fail(message: string): void {\n    assert(false, message);\n}\n","import { assert } from './asserts';\nimport { MutablePosition } from './MutablePosition';\n\nexport class MutableRange {\n    /**\n     *\n     */\n    constructor(public readonly begin: MutablePosition, public readonly end: MutablePosition) {\n        assert(begin, \"begin must be defined\");\n        assert(end, \"end must be defined\");\n        this.begin = begin;\n        this.end = end;\n    }\n    offset(rows: number, cols: number): void {\n        this.begin.offset(rows, cols);\n        this.end.offset(rows, cols);\n    }\n    toString(): string {\n        return `${this.begin} to ${this.end}`;\n    }\n}\n","export class Position {\n    /**\n     * 1-based line number.\n     */\n    public readonly line: number;\n    /**\n     * 0-based column index.\n     */\n    public readonly column: number;\n    /**\n     *\n     */\n    constructor(line: number, column: number) {\n        this.line = line;\n        this.column = column;\n    }\n    toString(): string {\n        return `[${this.line}, ${this.column}]`;\n    }\n}\n\nexport function positionComparator(a: Position, b: Position): -1 | 1 | 0 {\n    if (a.line < b.line) {\n        return -1;\n    }\n    else if (a.line > b.line) {\n        return 1;\n    }\n    else {\n        if (a.column < b.column) {\n            return -1;\n        }\n        else if (a.column > b.column) {\n            return 1;\n        }\n        else {\n            return 0;\n        }\n    }\n}\n","import { assert } from './asserts';\nimport { Position } from './Position';\n\nexport class Range {\n    /**\n     * begin is always defined.\n     */\n    public readonly begin: Position;\n    /**\n     * end is always defined.\n     */\n    public readonly end: Position;\n    /**\n     *\n     */\n    constructor(begin: Position, end: Position) {\n        assert(begin, \"begin must be defined\");\n        assert(end, \"end must be defined\");\n        this.begin = begin;\n        this.end = end;\n    }\n    toString(): string {\n        return `${this.begin} to ${this.end}`;\n    }\n}\n","import { assert } from './asserts';\nimport { Range } from './Range';\nimport { MutableRange } from './MutableRange';\n\n/**\n * A tree that enables ranges in the source document to be mapped to ranges in the target document.\n * The ordering of child nodes is not defined.\n * In many cases the children will be in target order owing to the writing process.\n * TODO: For more efficient searching, children should be sorted in source order.\n */\nexport class MappingTree {\n    /**\n     * source is always defined.\n     */\n    public readonly source: Range;\n    /**\n     * target is always defined.\n     */\n    public readonly target: MutableRange;\n    /**\n     *\n     * @param source\n     * @param target\n     * @param children\n     */\n    constructor(source: Range, target: MutableRange, public readonly children: MappingTree[]) {\n        assert(source, \"source must be defined\");\n        assert(target, \"target must be defined\");\n        this.source = source;\n        this.target = target;\n    }\n    offset(rows: number, cols: number) {\n        if (this.target) {\n            this.target.offset(rows, cols);\n        }\n        if (this.children) {\n            for (const child of this.children) {\n                child.offset(rows, cols);\n            }\n        }\n    }\n    mappings(): { source: Range, target: MutableRange }[] {\n        if (this.children) {\n            const maps: { source: Range, target: MutableRange }[] = [];\n            for (const child of this.children) {\n                for (const map of child.mappings()) {\n                    maps.push(map);\n                }\n            }\n            return maps;\n        }\n        else {\n            return [{ source: this.source, target: this.target }];\n        }\n    }\n}\n","import { assert } from './asserts';\nimport { Position } from './Position';\nimport { Range } from './Range';\nimport { MutablePosition } from './MutablePosition';\nimport { MutableRange } from './MutableRange';\nimport { MappingTree } from './MappingTree';\n\nexport enum IndentStyle {\n    None = 0,\n    Block = 1,\n    Smart = 2,\n}\n\nexport interface EditorOptions {\n    baseIndentSize?: number;\n    indentSize?: number;\n    tabSize?: number;\n    newLineCharacter?: string;\n    convertTabsToSpaces?: boolean;\n    indentStyle?: IndentStyle;\n}\n\nexport interface FormatCodeOptions extends EditorOptions {\n    insertSpaceAfterCommaDelimiter?: boolean;\n    insertSpaceAfterSemicolonInForStatements?: boolean;\n    insertSpaceBeforeAndAfterBinaryOperators?: boolean;\n    insertSpaceAfterConstructor?: boolean;\n    insertSpaceAfterKeywordsInControlFlowStatements?: boolean;\n    insertSpaceAfterFunctionKeywordForAnonymousFunctions?: boolean;\n    insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis?: boolean;\n    insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets?: boolean;\n    insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces?: boolean;\n    insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces?: boolean;\n    insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces?: boolean;\n    insertSpaceAfterTypeAssertion?: boolean;\n    insertSpaceBeforeFunctionParenthesis?: boolean;\n    placeOpenBraceOnNewLineForFunctions?: boolean;\n    placeOpenBraceOnNewLineForControlBlocks?: boolean;\n}\n\nclass StackElement {\n    private readonly texts: string[] = [];\n    private readonly trees: MappingTree[] = [];\n    // FIXME: A mutable position can be renamed to a Cursor.\n    private readonly cursor: MutablePosition;\n    constructor(public readonly bMark: string, public readonly eMark: string, targetBeginLine: number, targetBeginColumn: number) {\n        this.cursor = new MutablePosition(targetBeginLine, targetBeginColumn);\n    }\n    /**\n     *\n     */\n    write(text: string, tree: MappingTree): void {\n        assert(typeof text === 'string', \"text must be a string\");\n        this.texts.push(text);\n        this.trees.push(tree);\n\n        const cursor = this.cursor;\n        const beginLine = cursor.line;\n        const beginColumn = cursor.column;\n        const endLine = cursor.line;\n        const endColumn = beginColumn + text.length;\n        if (tree) {\n            tree.target.begin.line = beginLine;\n            tree.target.begin.column = beginColumn;\n            tree.target.end.line = endLine;\n            tree.target.end.column = endColumn;\n        }\n        cursor.line = endLine;\n        cursor.column = endColumn;\n    }\n    snapshot(): { text: string; tree: MappingTree; targetEndLine: number; targetEndColumn: number } {\n        const texts = this.texts;\n        const trees = this.trees;\n        const N = texts.length;\n        if (N === 0) {\n            return this.package('', null);\n        }\n        else {\n            let sBL = Number.MAX_SAFE_INTEGER;\n            let sBC = Number.MAX_SAFE_INTEGER;\n            let sEL = Number.MIN_SAFE_INTEGER;\n            let sEC = Number.MIN_SAFE_INTEGER;\n            let tBL = Number.MAX_SAFE_INTEGER;\n            let tBC = Number.MAX_SAFE_INTEGER;\n            let tEL = Number.MIN_SAFE_INTEGER;\n            let tEC = Number.MIN_SAFE_INTEGER;\n            const children: MappingTree[] = [];\n            for (let i = 0; i < N; i++) {\n                const tree = trees[i];\n                if (tree) {\n                    sBL = Math.min(sBL, tree.source.begin.line);\n                    sBC = Math.min(sBC, tree.source.begin.column);\n                    sEL = Math.max(sEL, tree.source.end.line);\n                    sEC = Math.max(sEC, tree.source.end.column);\n\n                    tBL = Math.min(tBL, tree.target.begin.line);\n                    tBC = Math.min(tBC, tree.target.begin.column);\n                    tEL = Math.max(tEL, tree.target.end.line);\n                    tEC = Math.max(tEC, tree.target.end.column);\n\n                    children.push(tree);\n                }\n            }\n            const text = texts.join(\"\");\n            if (children.length > 1) {\n                const source = new Range(new Position(sBL, sBC), new Position(sEL, sEC));\n                const target = new MutableRange(new MutablePosition(tBL, tBC), new MutablePosition(tEL, tEC));\n                return this.package(text, new MappingTree(source, target, children));\n            }\n            else if (children.length === 1) {\n                return this.package(text, children[0]);\n            }\n            else {\n                return this.package(text, null);\n            }\n        }\n    }\n    private package(text: string, tree: MappingTree): { text: string; tree: MappingTree; targetEndLine: number; targetEndColumn: number } {\n        return { text, tree, targetEndLine: this.cursor.line, targetEndColumn: this.cursor.column };\n    }\n\n    public getLine(): number {\n        return this.cursor.line;\n    }\n    public getColumn(): number {\n        return this.cursor.column;\n    }\n}\n\nfunction IDXLAST<T>(xs: ArrayLike<T>): number {\n    return xs.length - 1;\n}\n\n/**\n *\n */\nclass Stack {\n    private readonly elements: StackElement[] = [];\n    constructor(begin: string, end: string, targetLine: number, targetColumn: number) {\n        this.elements.push(new StackElement(begin, end, targetLine, targetColumn));\n    }\n    get length() {\n        return this.elements.length;\n    }\n    push(element: StackElement): void {\n        this.elements.push(element);\n    }\n    pop(): StackElement {\n        return this.elements.pop();\n    }\n    write(text: string, tree: MappingTree): void {\n        this.elements[IDXLAST(this.elements)].write(text, tree);\n    }\n    dispose(): TextAndMappings {\n        assert(this.elements.length === 1, \"stack length should be 1\");\n        const textAndMappings = this.elements[IDXLAST(this.elements)].snapshot();\n        this.pop();\n        assert(this.elements.length === 0, \"stack length should be 0\");\n        return textAndMappings;\n    }\n    getLine(): number {\n        return this.elements[IDXLAST(this.elements)].getLine();\n    }\n    getColumn(): number {\n        return this.elements[IDXLAST(this.elements)].getColumn();\n    }\n}\n\nexport interface TextAndMappings {\n    text: string;\n    tree: MappingTree;\n}\n\n/**\n * A smart buffer for writing TypeScript code.\n */\nexport class CodeWriter {\n    private readonly stack: Stack;\n    /**\n     * Determines the indentation.\n     */\n    // private indentLevel = 0;\n    /**\n     * Constructs a CodeWriter instance using the specified options.\n     */\n    constructor(beginLine: number, beginColumn: number, private options: FormatCodeOptions = {}) {\n        this.stack = new Stack('', '', beginLine, beginColumn);\n    }\n    assign(text: '=', source: Range): void {\n        const target = new MutableRange(new MutablePosition(-3, -3), new MutablePosition(-3, -3));\n        const tree = new MappingTree(source, target, null);\n        this.stack.write(text, tree);\n    }\n    /**\n     * Writes a name (identifier).\n     * @param id The identifier string to be written.\n     * @param begin The position of the beginning of the name in the original source.\n     * @param end The position of the end of the name in the original source.\n     */\n    name(id: string, source: Range): void {\n        if (source) {\n            const target = new MutableRange(new MutablePosition(-2, -2), new MutablePosition(-2, -2));\n            const tree = new MappingTree(source, target, null);\n            this.stack.write(id, tree);\n        }\n        else {\n            this.stack.write(id, null);\n        }\n    }\n    num(text: string, source: Range): void {\n        if (source) {\n            const target = new MutableRange(new MutablePosition(-3, -3), new MutablePosition(-3, -3));\n            const tree = new MappingTree(source, target, null);\n            this.stack.write(text, tree);\n        }\n        else {\n            this.stack.write(text, null);\n        }\n    }\n    /**\n     * Currently defined to be for string literals in unparsed form.\n     */\n    str(text: string, source: Range): void {\n        if (source) {\n            const target = new MutableRange(new MutablePosition(-23, -23), new MutablePosition(-23, -23));\n            const tree = new MappingTree(source, target, null);\n            this.stack.write(text, tree);\n        }\n        else {\n            this.stack.write(text, null);\n        }\n    }\n    write(text: string, tree: MappingTree): void {\n        this.stack.write(text, tree);\n    }\n    snapshot(): TextAndMappings {\n        assert(this.stack.length === 1, \"stack length is not zero\");\n        return this.stack.dispose();\n    }\n    binOp(binOp: '+' | '-' | '*' | '/' | '|' | '^' | '&' | '<<' | '>>' | '%' | '//' | '**', source: Range): void {\n        const target = new MutableRange(new MutablePosition(-5, -5), new MutablePosition(-5, -5));\n        const tree = new MappingTree(source, target, null);\n        if (this.options.insertSpaceBeforeAndAfterBinaryOperators) {\n            this.space();\n            this.stack.write(binOp, tree);\n            this.space();\n        }\n        else {\n            this.stack.write(binOp, tree);\n        }\n    }\n    unaryOp(unaryOp: '+' | '-' | '~' | '!', source: Range): void {\n        const target = new MutableRange(new MutablePosition(-5, -5), new MutablePosition(-5, -5));\n        const tree = new MappingTree(source, target, null);\n        this.stack.write(unaryOp, tree);\n    }\n    comma(begin: Position | null, end: Position | null): void {\n        if (begin && end) {\n            const source = new Range(begin, end);\n            const target = new MutableRange(new MutablePosition(-4, -4), new MutablePosition(-4, -4));\n            const tree = new MappingTree(source, target, null);\n            this.stack.write(',', tree);\n        }\n        else {\n            this.stack.write(',', null);\n        }\n        if (this.options.insertSpaceAfterCommaDelimiter) {\n            this.stack.write(' ', null);\n        }\n    }\n    space(): void {\n        this.stack.write(' ', null);\n    }\n    beginBlock(): void {\n        this.prolog('{', '}');\n    }\n    endBlock(): void {\n        this.epilog(false);\n    }\n    beginBracket(): void {\n        this.prolog('[', ']');\n    }\n    endBracket(): void {\n        this.epilog(this.options.insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets);\n    }\n    beginObject(): void {\n        this.prolog('{', '}');\n    }\n    endObject(): void {\n        this.epilog(this.options.insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces);\n    }\n    openParen(): void {\n        this.prolog('(', ')');\n    }\n    closeParen(): void {\n        this.epilog(this.options.insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis);\n    }\n    beginQuote(): void {\n        this.prolog(\"'\", \"'\");\n    }\n    endQuote(): void {\n        this.epilog(false);\n    }\n    beginStatement(): void {\n        this.prolog('', ';');\n    }\n    endStatement(): void {\n        this.epilog(false);\n    }\n    private prolog(bMark: string, eMark: string): void {\n        const line = this.stack.getLine();\n        const column = this.stack.getColumn();\n        this.stack.push(new StackElement(bMark, eMark, line, column));\n    }\n    private epilog(insertSpaceAfterOpeningAndBeforeClosingNonempty: boolean | undefined): void {\n        const popped = this.stack.pop();\n        const textAndMappings = popped.snapshot();\n        const text = textAndMappings.text;\n        const tree = textAndMappings.tree;\n        // This is where we would be\n        // const line = textAndMappings.targetEndLine;\n        // const column = textAndMappings.targetEndColumn;\n        if (text.length > 0 && insertSpaceAfterOpeningAndBeforeClosingNonempty) {\n            this.write(popped.bMark, null);\n            this.space();\n            const rows = 0;\n            const cols = popped.bMark.length + 1;\n            if (tree) {\n                tree.offset(rows, cols);\n            }\n            this.write(text, tree);\n            this.space();\n            this.write(popped.eMark, null);\n        }\n        else {\n            this.write(popped.bMark, null);\n            const rows = 0;\n            const cols = popped.bMark.length;\n            if (tree) {\n                tree.offset(rows, cols);\n            }\n            this.write(text, tree);\n            this.write(popped.eMark, null);\n        }\n    }\n}\n"],"names":["IndentStyle"],"mappings":"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"}